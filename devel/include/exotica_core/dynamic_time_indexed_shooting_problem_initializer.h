// This file was automatically generated. Do not edit this file!
#ifndef INITIALIZER_EXOTICA_CORE_DYNAMIC_TIME_INDEXED_SHOOTING_PROBLEM_INITIALIZER_H
#define INITIALIZER_EXOTICA_CORE_DYNAMIC_TIME_INDEXED_SHOOTING_PROBLEM_INITIALIZER_H

#include <exotica_core/property.h>

namespace exotica
{
inline std::vector<Initializer> GetExoticaCoreInitializers();
}

namespace exotica
{

class DynamicTimeIndexedShootingProblemInitializer : public InitializerBase
{
public:
    static std::string GetContainerName() {return "exotica/DynamicTimeIndexedShootingProblem" ;}

    DynamicTimeIndexedShootingProblemInitializer() : InitializerBase(),
        Debug( false) ,
        Maps( std::vector<exotica::Initializer>()) ,
        StartState( Eigen::VectorXd()) ,
        StartTime( 0) ,
        DerivativeOrder( -1) ,
        Cost( std::vector<exotica::Initializer>()) ,
        Q( Eigen::VectorXd()) ,
        Qf( Eigen::VectorXd()) ,
        R( Eigen::VectorXd()) ,
        GoalState( Eigen::VectorXd()) ,
        Q_rate( 1.) ,
        Qf_rate( 1.) ,
        R_rate( 1.) ,
        C( Eigen::VectorXd()) ,
        C_rate( 0) ,
        CW( Eigen::VectorXd()) ,
        CW_rate( 0) ,
        WarmStartWithInverseDynamics( false) 
    {
    }

    DynamicTimeIndexedShootingProblemInitializer( std::string _Name, exotica::Initializer _PlanningScene, int _T, double _tau, bool _Debug =  false, std::vector<exotica::Initializer> _Maps =  std::vector<exotica::Initializer>(), Eigen::VectorXd _StartState =  Eigen::VectorXd(), double _StartTime =  0, int _DerivativeOrder =  -1, std::vector<exotica::Initializer> _Cost =  std::vector<exotica::Initializer>(), Eigen::VectorXd _Q =  Eigen::VectorXd(), Eigen::VectorXd _Qf =  Eigen::VectorXd(), Eigen::VectorXd _R =  Eigen::VectorXd(), Eigen::VectorXd _GoalState =  Eigen::VectorXd(), double _Q_rate =  1., double _Qf_rate =  1., double _R_rate =  1., Eigen::VectorXd _C =  Eigen::VectorXd(), double _C_rate =  0, Eigen::VectorXd _CW =  Eigen::VectorXd(), double _CW_rate =  0, bool _WarmStartWithInverseDynamics =  false) : InitializerBase(),
        Name(_Name) ,
        PlanningScene(_PlanningScene) ,
        T(_T) ,
        tau(_tau) ,
        Debug(_Debug) ,
        Maps(_Maps) ,
        StartState(_StartState) ,
        StartTime(_StartTime) ,
        DerivativeOrder(_DerivativeOrder) ,
        Cost(_Cost) ,
        Q(_Q) ,
        Qf(_Qf) ,
        R(_R) ,
        GoalState(_GoalState) ,
        Q_rate(_Q_rate) ,
        Qf_rate(_Qf_rate) ,
        R_rate(_R_rate) ,
        C(_C) ,
        C_rate(_C_rate) ,
        CW(_CW) ,
        CW_rate(_CW_rate) ,
        WarmStartWithInverseDynamics(_WarmStartWithInverseDynamics) 
    {
    }

    DynamicTimeIndexedShootingProblemInitializer(const Initializer& other) : DynamicTimeIndexedShootingProblemInitializer()
    {
        if (other.HasProperty("Name")) {const Property& prop=other.properties_.at("Name"); if(prop.IsSet()) Name = boost::any_cast<std::string>(prop.Get());}
        if (other.HasProperty("PlanningScene")) {const Property& prop=other.properties_.at("PlanningScene"); if(prop.IsSet()) PlanningScene = prop.IsInitializerVectorType()?boost::any_cast<std::vector<exotica::Initializer>>(prop.Get()).at(0):boost::any_cast<exotica::Initializer>(prop.Get());}
        if (other.HasProperty("T")) {const Property& prop=other.properties_.at("T"); if(prop.IsSet()) T = prop.IsStringType()?ParseInt(boost::any_cast<std::string>(prop.Get())):boost::any_cast<int>(prop.Get());}
        if (other.HasProperty("tau")) {const Property& prop=other.properties_.at("tau"); if(prop.IsSet()) tau = prop.IsStringType()?ParseDouble(boost::any_cast<std::string>(prop.Get())):boost::any_cast<double>(prop.Get());}
        if (other.HasProperty("Debug")) {const Property& prop=other.properties_.at("Debug"); if(prop.IsSet()) Debug = prop.IsStringType()?ParseBool(boost::any_cast<std::string>(prop.Get())):boost::any_cast<bool>(prop.Get());}
        if (other.HasProperty("Maps")) {const Property& prop=other.properties_.at("Maps"); if(prop.IsSet()) Maps = boost::any_cast<std::vector<exotica::Initializer>>(prop.Get());}
        if (other.HasProperty("StartState")) {const Property& prop=other.properties_.at("StartState"); if(prop.IsSet()) StartState = prop.IsStringType()?ParseVector<double,Eigen::Dynamic>(boost::any_cast<std::string>(prop.Get())):boost::any_cast<Eigen::VectorXd>(prop.Get());}
        if (other.HasProperty("StartTime")) {const Property& prop=other.properties_.at("StartTime"); if(prop.IsSet()) StartTime = prop.IsStringType()?ParseDouble(boost::any_cast<std::string>(prop.Get())):boost::any_cast<double>(prop.Get());}
        if (other.HasProperty("DerivativeOrder")) {const Property& prop=other.properties_.at("DerivativeOrder"); if(prop.IsSet()) DerivativeOrder = prop.IsStringType()?ParseInt(boost::any_cast<std::string>(prop.Get())):boost::any_cast<int>(prop.Get());}
        if (other.HasProperty("Cost")) {const Property& prop=other.properties_.at("Cost"); if(prop.IsSet()) Cost = boost::any_cast<std::vector<exotica::Initializer>>(prop.Get());}
        if (other.HasProperty("Q")) {const Property& prop=other.properties_.at("Q"); if(prop.IsSet()) Q = prop.IsStringType()?ParseVector<double,Eigen::Dynamic>(boost::any_cast<std::string>(prop.Get())):boost::any_cast<Eigen::VectorXd>(prop.Get());}
        if (other.HasProperty("Qf")) {const Property& prop=other.properties_.at("Qf"); if(prop.IsSet()) Qf = prop.IsStringType()?ParseVector<double,Eigen::Dynamic>(boost::any_cast<std::string>(prop.Get())):boost::any_cast<Eigen::VectorXd>(prop.Get());}
        if (other.HasProperty("R")) {const Property& prop=other.properties_.at("R"); if(prop.IsSet()) R = prop.IsStringType()?ParseVector<double,Eigen::Dynamic>(boost::any_cast<std::string>(prop.Get())):boost::any_cast<Eigen::VectorXd>(prop.Get());}
        if (other.HasProperty("GoalState")) {const Property& prop=other.properties_.at("GoalState"); if(prop.IsSet()) GoalState = prop.IsStringType()?ParseVector<double,Eigen::Dynamic>(boost::any_cast<std::string>(prop.Get())):boost::any_cast<Eigen::VectorXd>(prop.Get());}
        if (other.HasProperty("Q_rate")) {const Property& prop=other.properties_.at("Q_rate"); if(prop.IsSet()) Q_rate = prop.IsStringType()?ParseDouble(boost::any_cast<std::string>(prop.Get())):boost::any_cast<double>(prop.Get());}
        if (other.HasProperty("Qf_rate")) {const Property& prop=other.properties_.at("Qf_rate"); if(prop.IsSet()) Qf_rate = prop.IsStringType()?ParseDouble(boost::any_cast<std::string>(prop.Get())):boost::any_cast<double>(prop.Get());}
        if (other.HasProperty("R_rate")) {const Property& prop=other.properties_.at("R_rate"); if(prop.IsSet()) R_rate = prop.IsStringType()?ParseDouble(boost::any_cast<std::string>(prop.Get())):boost::any_cast<double>(prop.Get());}
        if (other.HasProperty("C")) {const Property& prop=other.properties_.at("C"); if(prop.IsSet()) C = prop.IsStringType()?ParseVector<double,Eigen::Dynamic>(boost::any_cast<std::string>(prop.Get())):boost::any_cast<Eigen::VectorXd>(prop.Get());}
        if (other.HasProperty("C_rate")) {const Property& prop=other.properties_.at("C_rate"); if(prop.IsSet()) C_rate = prop.IsStringType()?ParseDouble(boost::any_cast<std::string>(prop.Get())):boost::any_cast<double>(prop.Get());}
        if (other.HasProperty("CW")) {const Property& prop=other.properties_.at("CW"); if(prop.IsSet()) CW = prop.IsStringType()?ParseVector<double,Eigen::Dynamic>(boost::any_cast<std::string>(prop.Get())):boost::any_cast<Eigen::VectorXd>(prop.Get());}
        if (other.HasProperty("CW_rate")) {const Property& prop=other.properties_.at("CW_rate"); if(prop.IsSet()) CW_rate = prop.IsStringType()?ParseDouble(boost::any_cast<std::string>(prop.Get())):boost::any_cast<double>(prop.Get());}
        if (other.HasProperty("WarmStartWithInverseDynamics")) {const Property& prop=other.properties_.at("WarmStartWithInverseDynamics"); if(prop.IsSet()) WarmStartWithInverseDynamics = prop.IsStringType()?ParseBool(boost::any_cast<std::string>(prop.Get())):boost::any_cast<bool>(prop.Get());}
    }

    virtual Initializer GetTemplate() const
    {
        return (Initializer)DynamicTimeIndexedShootingProblemInitializer();
    }

    virtual std::vector<Initializer> GetAllTemplates() const
    {
        return GetExoticaCoreInitializers();
    }

    virtual void Check(const Initializer& other) const
    {
        if(!other.HasProperty("Name") || !other.properties_.at("Name").IsSet()) ThrowPretty("Initializer DynamicTimeIndexedShootingProblemInitializer requires property Name to be set!");
        if(!other.HasProperty("PlanningScene") || !other.properties_.at("PlanningScene").IsSet()) ThrowPretty("Initializer DynamicTimeIndexedShootingProblemInitializer requires property PlanningScene to be set!");
        if(!other.HasProperty("T") || !other.properties_.at("T").IsSet()) ThrowPretty("Initializer DynamicTimeIndexedShootingProblemInitializer requires property T to be set!");
        if(!other.HasProperty("tau") || !other.properties_.at("tau").IsSet()) ThrowPretty("Initializer DynamicTimeIndexedShootingProblemInitializer requires property tau to be set!");
    }

    operator Initializer()
    {
        Initializer ret(GetContainerName());
        ret.properties_.emplace("Name", Property("Name", true, boost::any(Name)));
        ret.properties_.emplace("PlanningScene", Property("PlanningScene", true, boost::any(PlanningScene)));
        ret.properties_.emplace("T", Property("T", true, boost::any(T)));
        ret.properties_.emplace("tau", Property("tau", true, boost::any(tau)));
        ret.properties_.emplace("Debug", Property("Debug", false, boost::any(Debug)));
        ret.properties_.emplace("Maps", Property("Maps", false, boost::any(Maps)));
        ret.properties_.emplace("StartState", Property("StartState", false, boost::any(StartState)));
        ret.properties_.emplace("StartTime", Property("StartTime", false, boost::any(StartTime)));
        ret.properties_.emplace("DerivativeOrder", Property("DerivativeOrder", false, boost::any(DerivativeOrder)));
        ret.properties_.emplace("Cost", Property("Cost", false, boost::any(Cost)));
        ret.properties_.emplace("Q", Property("Q", false, boost::any(Q)));
        ret.properties_.emplace("Qf", Property("Qf", false, boost::any(Qf)));
        ret.properties_.emplace("R", Property("R", false, boost::any(R)));
        ret.properties_.emplace("GoalState", Property("GoalState", false, boost::any(GoalState)));
        ret.properties_.emplace("Q_rate", Property("Q_rate", false, boost::any(Q_rate)));
        ret.properties_.emplace("Qf_rate", Property("Qf_rate", false, boost::any(Qf_rate)));
        ret.properties_.emplace("R_rate", Property("R_rate", false, boost::any(R_rate)));
        ret.properties_.emplace("C", Property("C", false, boost::any(C)));
        ret.properties_.emplace("C_rate", Property("C_rate", false, boost::any(C_rate)));
        ret.properties_.emplace("CW", Property("CW", false, boost::any(CW)));
        ret.properties_.emplace("CW_rate", Property("CW_rate", false, boost::any(CW_rate)));
        ret.properties_.emplace("WarmStartWithInverseDynamics", Property("WarmStartWithInverseDynamics", false, boost::any(WarmStartWithInverseDynamics)));
        return ret;
    }

    std::string Name;
    exotica::Initializer PlanningScene;
    int T;
    double tau;
    bool Debug;
    std::vector<exotica::Initializer> Maps;
    Eigen::VectorXd StartState;
    double StartTime;
    int DerivativeOrder;
    std::vector<exotica::Initializer> Cost;
    Eigen::VectorXd Q;
    Eigen::VectorXd Qf;
    Eigen::VectorXd R;
    Eigen::VectorXd GoalState;
    double Q_rate;
    double Qf_rate;
    double R_rate;
    Eigen::VectorXd C;
    double C_rate;
    Eigen::VectorXd CW;
    double CW_rate;
    bool WarmStartWithInverseDynamics;
};

}

#include<exotica_core/exotica_core_initializers_numerator.h>

#include <exotica_core/scene_initializer.h>

#endif