// This file was automatically generated. Do not edit this file!
#ifndef INITIALIZER_EXOTICA_AICO_SOLVER_BAYESIAN_IK_SOLVER_INITIALIZER_H
#define INITIALIZER_EXOTICA_AICO_SOLVER_BAYESIAN_IK_SOLVER_INITIALIZER_H

#include <exotica_core/property.h>

namespace exotica
{
inline std::vector<Initializer> GetExoticaAicoSolverInitializers();
}

namespace exotica
{

class BayesianIKSolverInitializer : public InitializerBase
{
public:
    static std::string GetContainerName() {return "exotica/BayesianIKSolver" ;}

    BayesianIKSolverInitializer() : InitializerBase(),
        Debug( false) ,
        MaxIterations( 100) ,
        SweepMode( "Symmetric") ,
        MaxBacktrackIterations( 10) ,
        StepTolerance( 1e-5) ,
        FunctionTolerance( 1e-5) ,
        MinStep( 1e-5) ,
        Damping( 0.01) ,
        UseBackwardMessage( false) ,
        Verbose( false) 
    {
    }

    BayesianIKSolverInitializer( std::string _Name, bool _Debug =  false, int _MaxIterations =  100, std::string _SweepMode =  "Symmetric", int _MaxBacktrackIterations =  10, double _StepTolerance =  1e-5, double _FunctionTolerance =  1e-5, double _MinStep =  1e-5, double _Damping =  0.01, bool _UseBackwardMessage =  false, bool _Verbose =  false) : InitializerBase(),
        Name(_Name) ,
        Debug(_Debug) ,
        MaxIterations(_MaxIterations) ,
        SweepMode(_SweepMode) ,
        MaxBacktrackIterations(_MaxBacktrackIterations) ,
        StepTolerance(_StepTolerance) ,
        FunctionTolerance(_FunctionTolerance) ,
        MinStep(_MinStep) ,
        Damping(_Damping) ,
        UseBackwardMessage(_UseBackwardMessage) ,
        Verbose(_Verbose) 
    {
    }

    BayesianIKSolverInitializer(const Initializer& other) : BayesianIKSolverInitializer()
    {
        if (other.HasProperty("Name")) {const Property& prop=other.properties_.at("Name"); if(prop.IsSet()) Name = boost::any_cast<std::string>(prop.Get());}
        if (other.HasProperty("Debug")) {const Property& prop=other.properties_.at("Debug"); if(prop.IsSet()) Debug = prop.IsStringType()?ParseBool(boost::any_cast<std::string>(prop.Get())):boost::any_cast<bool>(prop.Get());}
        if (other.HasProperty("MaxIterations")) {const Property& prop=other.properties_.at("MaxIterations"); if(prop.IsSet()) MaxIterations = prop.IsStringType()?ParseInt(boost::any_cast<std::string>(prop.Get())):boost::any_cast<int>(prop.Get());}
        if (other.HasProperty("SweepMode")) {const Property& prop=other.properties_.at("SweepMode"); if(prop.IsSet()) SweepMode = boost::any_cast<std::string>(prop.Get());}
        if (other.HasProperty("MaxBacktrackIterations")) {const Property& prop=other.properties_.at("MaxBacktrackIterations"); if(prop.IsSet()) MaxBacktrackIterations = prop.IsStringType()?ParseInt(boost::any_cast<std::string>(prop.Get())):boost::any_cast<int>(prop.Get());}
        if (other.HasProperty("StepTolerance")) {const Property& prop=other.properties_.at("StepTolerance"); if(prop.IsSet()) StepTolerance = prop.IsStringType()?ParseDouble(boost::any_cast<std::string>(prop.Get())):boost::any_cast<double>(prop.Get());}
        if (other.HasProperty("FunctionTolerance")) {const Property& prop=other.properties_.at("FunctionTolerance"); if(prop.IsSet()) FunctionTolerance = prop.IsStringType()?ParseDouble(boost::any_cast<std::string>(prop.Get())):boost::any_cast<double>(prop.Get());}
        if (other.HasProperty("MinStep")) {const Property& prop=other.properties_.at("MinStep"); if(prop.IsSet()) MinStep = prop.IsStringType()?ParseDouble(boost::any_cast<std::string>(prop.Get())):boost::any_cast<double>(prop.Get());}
        if (other.HasProperty("Damping")) {const Property& prop=other.properties_.at("Damping"); if(prop.IsSet()) Damping = prop.IsStringType()?ParseDouble(boost::any_cast<std::string>(prop.Get())):boost::any_cast<double>(prop.Get());}
        if (other.HasProperty("UseBackwardMessage")) {const Property& prop=other.properties_.at("UseBackwardMessage"); if(prop.IsSet()) UseBackwardMessage = prop.IsStringType()?ParseBool(boost::any_cast<std::string>(prop.Get())):boost::any_cast<bool>(prop.Get());}
        if (other.HasProperty("Verbose")) {const Property& prop=other.properties_.at("Verbose"); if(prop.IsSet()) Verbose = prop.IsStringType()?ParseBool(boost::any_cast<std::string>(prop.Get())):boost::any_cast<bool>(prop.Get());}
    }

    virtual Initializer GetTemplate() const
    {
        return (Initializer)BayesianIKSolverInitializer();
    }

    virtual std::vector<Initializer> GetAllTemplates() const
    {
        return GetExoticaAicoSolverInitializers();
    }

    virtual void Check(const Initializer& other) const
    {
        if(!other.HasProperty("Name") || !other.properties_.at("Name").IsSet()) ThrowPretty("Initializer BayesianIKSolverInitializer requires property Name to be set!");
    }

    operator Initializer()
    {
        Initializer ret(GetContainerName());
        ret.properties_.emplace("Name", Property("Name", true, boost::any(Name)));
        ret.properties_.emplace("Debug", Property("Debug", false, boost::any(Debug)));
        ret.properties_.emplace("MaxIterations", Property("MaxIterations", false, boost::any(MaxIterations)));
        ret.properties_.emplace("SweepMode", Property("SweepMode", false, boost::any(SweepMode)));
        ret.properties_.emplace("MaxBacktrackIterations", Property("MaxBacktrackIterations", false, boost::any(MaxBacktrackIterations)));
        ret.properties_.emplace("StepTolerance", Property("StepTolerance", false, boost::any(StepTolerance)));
        ret.properties_.emplace("FunctionTolerance", Property("FunctionTolerance", false, boost::any(FunctionTolerance)));
        ret.properties_.emplace("MinStep", Property("MinStep", false, boost::any(MinStep)));
        ret.properties_.emplace("Damping", Property("Damping", false, boost::any(Damping)));
        ret.properties_.emplace("UseBackwardMessage", Property("UseBackwardMessage", false, boost::any(UseBackwardMessage)));
        ret.properties_.emplace("Verbose", Property("Verbose", false, boost::any(Verbose)));
        return ret;
    }

    std::string Name;
    bool Debug;
    int MaxIterations;
    std::string SweepMode;
    int MaxBacktrackIterations;
    double StepTolerance;
    double FunctionTolerance;
    double MinStep;
    double Damping;
    bool UseBackwardMessage;
    bool Verbose;
};

}

#include<exotica_aico_solver/exotica_aico_solver_initializers_numerator.h>


#endif