..  _task_space_vector:

Task space vector handling
==========================

The output of a task map is a representation of the robot's state in the task space. Most task spaces are :math:`\mathbb{R}^n`. As such, they can be stored and handled as vectors of real numbers. However, some task maps output configurations in the :math:`SO(3)` or the :math:`SE(3)` space. In this case, `Lie group algebra <http://ingmec.ual.es/~jlblanco/papers/jlblanco2010geometry3D_techrep.pdf>`_ has to be used to correctly compute the additions and subtractions in the task space. The ``task space vector`` implements operations on task spaces. The ``task space vector`` is a data structure that keeps track of :math:`SO(3)` sub-groups within the stored vector. The operations on this vector then implement the Lie group algebra. For example, a spatial frame may be stored as a transformation matrix :math:`M_A^B\in\mathbb{R}^{4\times4}`. This matrix will be stored in the ``task space vector``. Performing addition and subtraction on the vector will then be incorrect. The correct transformation is performed by a matrix multiplication. The ``task space vector`` keeps track of transformations stored within its structure and applies the correct operations on them. Furthermore, the result of subtraction is always a geometric twist, e.g., :math:`M_A^B-M_C^B={^B\boldsymbol{t}_A^C}`. This makes it possible to multiply the result of this operation with a geometric Jacobian, producing a geometrically correct relative transformation. This feature has been used in the implementation of the `inverse kinematics solver <http://dynamicsystems.asmedigitalcollection.asme.org/article.aspx?articleid=1403812>`_ and the `AICO solver <http://doi.acm.org/10.1145/1553374.1553508>`_. Additionally,
a :math:`SO(3)` rotation can be represented and stored in different ways, e.g. as a unit quaternion :math:`\boldsymbol{R}_\mathcal{Q}\in\mathbb{R}^4 \text{ where } ||\boldsymbol{R}_\mathcal{Q}||=1`, Euler angles :math:`\boldsymbol{R}_\mathcal{ZYZ},\boldsymbol{R}_\mathcal{ZYX},\boldsymbol{R}_\mathcal{RPY}\in\mathbb{R}^3`, angle-axis representation :math:`\boldsymbol{R}_\mathcal{A}\in\mathbb{R}^3 \text{ where } ||R_\mathcal{A}||=\theta`, rotation matrix :math:`\boldsymbol{R}\in\mathbb{R}^{3\times3}`, etc. We handle these representations implicitly. Each sub-group of the ``task space vector`` stores the size and type of representation that was used. The operations on the vector first convert the task space coordinates into a rotation matrix representation, then the correct spatial operation is applied and a twist is computed. As a result the input and output dimension may vary, i.e. subtraction of two rotations represented as rotation matrices is a function :math:`f(R_1, R_2): \mathbb{R}^9 \rightarrow \mathbb{R}^3`. The result is the angular velocity component of the twist. The ``task space vector`` is composed by concatenating outputs of multiple task maps. Each task map specifies if its output contains any components that have to be handled using the Lie group algebra.

.. image:: ../images/taskspace.png
    :width: 100%
    :align: center

Task space vector data packing combining three position coordinates :math:`x, y, z\in \mathbb{R}` and a sub-vector containing a :math:`SO(3)` rotation represented as a unit quaternion. The subtraction calculation of two task space vectors :math:`\boldsymbol{y}_1` and :math:`\boldsymbol{y}_2` first converts the quaternions into rotation matrices :math:`R_1` and :math:`R_2` and performs the rotation operation :math:`R_2^{-1}R_1`. The result is then converted into angular velocities :math:`\omega_x, \omega_y, \omega_z` and packed into the output vector :math:`\vartriangle\!\!y`. Notice that the dimensionality of :math:`\vartriangle\!\!\boldsymbol{y}\in\mathbb{R}^6` and :math:`\boldsymbol{y}_1, \boldsymbol{y}_2\in\mathbb{R}^7` are different.